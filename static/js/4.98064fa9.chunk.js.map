{"version":3,"sources":["utils/hooks.tsx","component/movieCard/index.tsx","utils/common-constant.ts","component/movieList/index.tsx"],"names":["useAppSelector","useSelector","MovieCard","length","index","finalMovieElementRef","movieData","url","ref","alt","name","src","img","onError","e","target","updateToDefaultImg","className","React","memo","MovieList","window","location","href","movies","state","movieList","dispatch","useDispatch","useState","page","setPage","total","setTotal","perPage","setPerPage","toggleSearch","setToggleSearch","observer","useRef","searchTerm","setSearchTerm","loading","setLoading","hasMore","setHasMore","heading","setHeading","useCallback","node","current","disconnect","IntersectionObserver","entries","isIntersecting","observe","useEffect","delayFn","setTimeout","getAllMovieData","clearTimeout","getMovieData","axios","get","then","res","data","actions","update","content","catch","err","generatePageArray","i","returnData","push","a","reset","pageArray","Promise","all","map","pageNumber","searchUpdate","resetMovieList","resetOnBack","style","backgroundColor","backgroundImage","onClick","type","placeholder","value","onChange"],"mappings":"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","file":"static/js/4.98064fa9.chunk.js","sourcesContent":["import { TypedUseSelectorHook, useDispatch, useSelector } from 'react-redux';\r\nimport store from '../store';\r\n\r\ntype AppDispatch = typeof store.dispatch;\r\ntype RootState = ReturnType<typeof store.getState>;\r\n\r\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\r\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;","import React from 'react'\r\nimport { MovieCardData } from '../../Interfaces/Movie';\r\nimport { movieCardBuffer } from '../../utils/common-constant';\r\n\r\n// Component memoized to remove unwanted rerendering\r\nconst MovieCard = ({ length, index, finalMovieElementRef, movieData, url }: MovieCardData) => {\r\n    // Added error function to replace with placeholder image\r\n    const updateToDefaultImg = (e: any) => {\r\n        e.target.src = `${url}/assets/Slices/placeholder_for_missing_posters.png`;\r\n    }\r\n    return (\r\n        <div key={index} ref={length === index + movieCardBuffer ? finalMovieElementRef : null}>\r\n            <img alt={movieData.name} src={`${url}/assets/Slices/${movieData.img}`} onError={(e) => updateToDefaultImg(e)} />\r\n            <span className=\"font-thin text-base\">{movieData.name}</span>\r\n        </div>\r\n    )\r\n}\r\nexport default React.memo(MovieCard);","// Movie List infinite scroll buffer\r\nexport const movieCardBuffer = 3;","import axios from 'axios';\r\nimport React, { useCallback, useEffect, useState, useRef } from 'react'\r\nimport { MovieDetails } from '../../Interfaces/Movie';\r\nimport { useAppDispatch, useAppSelector } from '../../utils/hooks';\r\nimport { actions } from '../../utils/movie-redux';\r\nimport Loader from '../loader';\r\nimport MovieCard from '../movieCard';\r\n\r\n// Main Movie List\r\nfunction MovieList() {\r\n    const url = window.location.href;\r\n    const movies = useAppSelector((state) => state.movieList.movies);\r\n    const dispatch = useAppDispatch();\r\n    const [page, setPage] = useState(1);\r\n    const [total, setTotal] = useState(0);\r\n    const [perPage, setPerPage] = useState(0);\r\n    const [toggleSearch, setToggleSearch] = useState(false);\r\n    const observer: any = useRef();\r\n    const [searchTerm, setSearchTerm] = useState('')\r\n    const [loading, setLoading] = useState(true);\r\n    const [hasMore, setHasMore] = useState(false);\r\n    const [heading, setHeading] = useState('');\r\n\r\n    // Used for infinte srool api call before reaching the end using the buffer. Page updated.\r\n    const finalMovieElementRef = useCallback(node => {\r\n        if (loading) return\r\n        if (observer.current) observer.current.disconnect();\r\n        observer.current = new IntersectionObserver(entries => {\r\n            if (entries[0].isIntersecting && hasMore) {\r\n                setPage(page => page + 1);\r\n            }\r\n        })\r\n        if (node) observer.current?.observe(node)\r\n    }, [loading, hasMore])\r\n\r\n    // Search input with timeout (let's user type, waiting for 1 sec before calling API) to load the whole data and filter out the required result\r\n    useEffect(() => {\r\n        if (!loading) {\r\n            const delayFn = setTimeout(() => {\r\n                getAllMovieData();\r\n            }, 1000);\r\n            return () => clearTimeout(delayFn);\r\n        }\r\n    }, [searchTerm]);\r\n\r\n\r\n    // On Page change the movie API is called.\r\n    useEffect(() => {\r\n        getMovieData();\r\n    }, [page]);\r\n\r\n    // Updating conditions for checking further loading.\r\n    useEffect(() => {\r\n        if (!searchTerm) {\r\n            setLoading(false);\r\n            setHasMore(movies.length < total);\r\n        }\r\n    }, [movies]);\r\n\r\n    // Get Movies Data based on the page and saves data in state and redux\r\n    const getMovieData = () => {\r\n        setLoading(true);\r\n        axios.get(`${url}/assets/API/CONTENTLISTINGPAGE-PAGE${page}.json`)\r\n            .then((res) => {\r\n                setHeading(res.data.page[\"title\"]);\r\n                setTotal(res.data.page[\"total-content-items\"]);\r\n                setPerPage(res.data.page[\"page-size-requested\"]);\r\n                dispatch(actions.update(res?.data?.page[\"content-items\"]?.content ? res.data.page[\"content-items\"].content : []));\r\n            }).catch((err) => {\r\n                setLoading(false);\r\n                setHasMore(false);\r\n            });\r\n    }\r\n\r\n    // Generate the all pages to get the data from API since we dont have a search API (FE filtering)\r\n    function generatePageArray() {\r\n        let i = 1;\r\n        let returnData = [];\r\n        while (i * perPage - total < perPage) {\r\n            returnData.push(i);\r\n            i++;\r\n        }\r\n        return returnData;\r\n    }\r\n    // Get all pages to do filtering based on search\r\n    const getAllMovieData = async () => {\r\n        setLoading(true);\r\n        dispatch(actions.reset());\r\n        const pageArray = generatePageArray();\r\n        await Promise.all(\r\n            pageArray.map(async (pageNumber: number) => {\r\n                await axios.get(`${url}/assets/API/CONTENTLISTINGPAGE-PAGE${pageNumber}.json`)\r\n                    .then((res) => {\r\n                        dispatch(actions.update(res?.data?.page[\"content-items\"]?.content ? res.data.page[\"content-items\"].content : []));\r\n                    }).catch((err) => {\r\n                        setLoading(false);\r\n                        setHasMore(false);\r\n                    });\r\n            })\r\n        );\r\n        dispatch(actions.searchUpdate(searchTerm));\r\n        setLoading(false);\r\n        setHasMore(false);\r\n    }\r\n\r\n    // Reset case on back button and on search close\r\n    const resetMovieList = (resetOnBack: boolean = false) => {\r\n        if (toggleSearch || resetOnBack) {\r\n            setLoading(true);\r\n            setSearchTerm('');\r\n            if (resetOnBack) setToggleSearch(false);\r\n            dispatch(actions.reset());\r\n            page === 1 ? getMovieData() : setPage(1);\r\n        }\r\n    }\r\n\r\n    return (\r\n        <div className=\" h-screen w-screen relative text-white font-body\" style={{ backgroundColor: \"#171717\" }}>\r\n            <div style={{ backgroundImage: `url(${url}/assets/Slices/nav_bar.png)` }} className=\"absolute inset-x-0 top-0 flex justify-between p-4 bg-no-repeat bg-contain bg-top w-full h-16\" >\r\n                <div className=\"flex items-center w-3/5\">\r\n                    <button className=\"w-5\" onClick={() => resetMovieList(true)}>\r\n                        <img alt=\"Back\" className=\"object-contain h-5 w-5\" src={`${url}/assets/Slices/Back.png`} />\r\n                    </button>\r\n                    <span className=\"ml-1 text-xl font-light whitespace-nowrap\">{heading}</span>\r\n                </div>\r\n                <div className={`flex items-center w-3/5 ml-1  text-gray-300 relative rounded-full p-2 border-2 ${toggleSearch ? 'bg-black border-white' : 'border-transparent'}`}>\r\n                    <input type=\"text\" placeholder=\"Search...\" value={searchTerm} className={`ml-2 w-full bg-transparent outline-none  transition ease-linear ${toggleSearch ? 'opacity-1' : 'opacity-0'}`} onChange={e => setSearchTerm(e.target.value)} />\r\n                    <button className=\"absolute right-0 mr-3 outline-none\" onClick={() => { resetMovieList(); setToggleSearch(!toggleSearch); }}>\r\n                        <img alt=\"Search\" className={`object-contain h-5 w-5`} src={`${url}/assets/Slices/search.png`} />\r\n                    </button>\r\n                </div>\r\n            </div>\r\n            {/* Conditional cases based on following cases\r\n            1. When No data is there\r\n                1. On Search\r\n                2. On Loading\r\n                3. When No Data is there\r\n            2.When Data is there */}\r\n            {movies.length === 0 ?\r\n                searchTerm ?\r\n                    <div className=\"flex align-middle px-4 h-screen w-auto justify-center pt-20\">No Movies Found</div>\r\n                    : loading ? <Loader /> : <div className=\"flex align-middle px-4 h-screen w-auto justify-center pt-20\">No Movies Available</div>\r\n                : <div className=\"grid grid-cols-3 gap-4 px-4 h-screen w-auto overflow-y-auto overflow-x-hidden pt-14\">\r\n                    {\r\n                        movies.map((data: MovieDetails, index: number) => {\r\n                            return (\r\n                                <MovieCard url={url} length={movies.length} index={index} finalMovieElementRef={finalMovieElementRef} movieData={data} />\r\n                            )\r\n                        })\r\n                    }\r\n                </div>\r\n            }\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default MovieList;\r\n\r\n"],"sourceRoot":""}